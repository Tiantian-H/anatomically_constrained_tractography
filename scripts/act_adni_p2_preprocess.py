#!/usr/bin/env python3
# 
# Network spreading models using personalised (age/gender-matched) connectomes 
# from PPMI healthy controls for anatomically constrained tractography
#
# ACT prep (MRTrix3 pipeline)
#
# Prerequisite: walk through previous steps in the documentation
#
# Neil Oxtoby, February 2020

import os,subprocess,glob
import pandas as pd

preproc_bool = True

#****** Local batch preprocessing using multicore CPU
n_cpus = 4

#* Name of CSV file containing image file paths and IDs: generated by act_adni_0_prep.py
csv_input_file = 'act_adni_filepaths.csv'

#* File locations
top_folder = '/cluster/project9/HCP_subjects/anatomically_constrained_tractography'
data_folder = os.path.join(top_folder,'ADNI')
act_folder  = os.path.normpath(os.path.join(data_folder,'act'))
dMRI_folder = os.path.normpath(os.path.join(act_folder,'dMRI'))
sMRI_folder = os.path.normpath(os.path.join(act_folder,'sMRI'))
json_folder = os.path.normpath(os.path.join(act_folder,'json'))
csv_input_path = os.path.join(top_folder,csv_input_file)
act_csv_path = os.path.join(act_folder,'act_adni.csv')

#* Preprocessing functions copied from my connectome pipeline
wd = os.path.join(top_folder,'scripts')
os.chdir(wd)
from act_utilities import *

#* Preprocessing output folders
denoise_tail = '_denoised'
preproc_tail = '_preproc'
biascorrect_tail = '_biascorrect'
dMRI_tails = [denoise_tail,preproc_tail,biascorrect_tail]
dMRI_preproc_folders = [os.path.join(act_folder,'dMRI%s' % d) for d in dMRI_tails]
reg_tail = '_reg'
sMRI_reg_folder      =  os.path.join(act_folder,'sMRI%s' % reg_tail)
make_sure_path_exists(sMRI_reg_folder)
for f in dMRI_preproc_folders:
    make_sure_path_exists(f)

os.chdir(act_folder)


#####################################################################################################
############ Prep: check for dependencies, convert dMRI to MIF, prepare output DataFrame ############
#* Check for dependencies: ANTS, etc.
depCheckVal = checkForDependencies()
if depCheckVal!=0:
    print('ERROR: missing dependency {0}'.format(depCheckVal))
    print('see checkForDependencies() function for details')
    sys.exit(depCheckVal)

#*** 5. run GIF3 / FreeSurfer on sMRI_registered
df_ = pd.read_csv(act_csv_path)
print("\nChecking whether you've run GIF on the sMRI (you'll have to change this for FreeSurfer, or remove: see below)\n")

# algorithm = 'gif3'
# sMRI_parc_txt = 'sMRI_%s' % algorithm
# gif_parc_tag = "_NeuroMorph_Parcellation.nii.gz"
# gif_folder = os.path.join(act_folder,sMRI_parc_txt)
# gif3_parcellations_path = glob.glob(os.path.join(gif_folder,"*/*%s" % gif_parc_tag))
# gif3_parcellations = [os.path.basename(g) for g in gif3_parcellations_path]
# df_gif3 = pd.DataFrame(columns=[sMRI_parc_txt],data=gif3_parcellations)
# df_gif3['Subject ID'] = df_gif3[sMRI_parc_txt].map(lambda x: x.split('_')[0]).astype(int)
# df = df_.merge(df_gif3,on='Subject ID')
# print(" > > > Found %i GIF3 parcellations out of %i" % (len(gif3_parcellations),df.shape[0]))

print("\nChecking whether you've run FreeSurfer on the sMRI\n")
algorithm = 'freesurfer'
sMRI_parc_txt = 'sMRI_%s' % algorithm
freesurfer_parc = "aparc+aseg.mgz"
freesurfer_folder = os.path.join(act_folder,sMRI_parc_txt)
freesurfer_parcellations_path = glob.glob(os.path.join(freesurfer_folder,"*/mri/%s" % freesurfer_parc))
#freesurfer_parcellations = freesurfer_parcellations_path # Could rename the files (to approximately match GIF filenames?)
df_freesurfer = pd.DataFrame(columns=[sMRI_parc_txt],data=freesurfer_parcellations_path)
# the index inside [] in the following command may need to be edited according to the way you name your file
df_freesurfer['Subject ID'] = df_freesurfer[sMRI_parc_txt].map(lambda x: x.split('/')[-3].split('_')[2]).astype(int)
df = df_.merge(df_freesurfer,on='Subject ID')
print(" > > > Found %i FreeSurfer parcellations out of %i" % (len(freesurfer_parcellations_path),df.shape[0]))


#*** 5.2 DWI masks
print(">>> DWI masks for dwi2fod")
masks_folder = os.path.join(act_folder,'dMRI_mask')
oot = os.system('mkdir -p %s' % masks_folder)
#* mrtrix3: dwi2mask
mask_tail = '_mask'
batch_cmd = [
    'for_each',
    'dMRI%s/*.mif' % biascorrect_tail,'-nthreads','%i' % n_cpus,':',
    'dwi2mask','IN','dMRI{0}/PRE{0}.mif'.format(mask_tail)
]
if preproc_bool:
    for_each_check = os.system(' '.join(batch_cmd))

#*** 6. ACT stuff: 5TT, nodes / WM_FODs (response functions & CSD)
algorithm = 'freesurfer'
sMRI_parc_txt = 'sMRI_%s' % algorithm
bizzi_lobes = False
if bizzi_lobes:
    algorithm_ = algorithm + "_bizzi2lobes"
else:
    algorithm_ = algorithm
sMRI_5tt_txt = 'Path_5tt_%s' % algorithm_
sMRI_nodes_txt = 'Path_nodes_%s' % algorithm_
#* labelconvert: use bizzi2lobes_cingsep_convert.txt (c.f. MRTRIX3:path/to/labelconvertLUTs/f2lobes....txt)
print(">>> ACT prep: 5TT, nodes, CSD (WM_FODs and response functions)")
print("    *** Chosen algorithm: %s (%s)" % (algorithm,algorithm_))
fivett_folder = os.path.join(act_folder,'sMRI_5tt')
oot = os.system('mkdir -p %s' % fivett_folder)
fttrc = -1
# df.drop(columns=[sMRI_nodes_txt],inplace=True)
for i in df.index.values:
    participant_id = df.at[i,'Subject ID']
    sMRI_reg = os.path.join(act_folder,'sMRI_reg',os.path.basename(df.at[i,'Path_sMRI_registered']))
    if algorithm == 'gif3':
        sMRI_gif = os.path.join(act_folder,sMRI_parc_txt,os.path.basename(df.at[i,sMRI_parc_txt]).replace(gif_parc_tag,'_share_apps_cmic_GIF_bin'),os.path.basename(df.at[i,sMRI_parc_txt]))
        sMRI_parc = sMRI_gif
        sMRI_5TT = os.path.join(fivett_folder,os.path.basename(sMRI_gif).replace(gif_parc_tag,'_5tt_%s.mif' % algorithm))
    elif algorithm == 'freesurfer':
        sMRI_freesurfer = df.at[i,sMRI_parc_txt]
        sMRI_parc = sMRI_freesurfer
        sMRI_5TT = os.path.join(fivett_folder,os.path.basename(sMRI_reg).replace('.nii.gz','_5tt_%s.mif' % algorithm))
    if not os.path.isfile(sMRI_5TT):
        fiveTT_check = subprocess.run(['5ttgen',algorithm,sMRI_parc,sMRI_5TT])
        fttrc = fiveTT_check.returncode
    else:
        print('5TT file found')
        fttrc = 0
    if fttrc == 0:
        df.at[i,sMRI_5tt_txt] = sMRI_5TT
        print('\t> > > \n\t> > > 5ttgen done. Proceeding with labelconvert\n\t> > >')
        (labelconvert_check,nodes) = convert_sMRI_labels(sMRI_parc,algorithm=algorithm,cluster=False,bizzi=bizzi_lobes)
        if labelconvert_check==0:
            df.at[i,sMRI_nodes_txt] = nodes
        else:
            df.at[i,sMRI_nodes_txt] = np.nan
    else:
        df.at[i,sMRI_5tt_txt] = np.nan
#* Move nodes files
nodes_folder = 'sMRI_nodes'
oot = os.system('mkdir -p %s' % os.path.join(act_folder,nodes_folder))
for i in df.index.values:
    nodes = df.at[i,sMRI_nodes_txt]
    nodes_new = nodes.replace("/"+ sMRI_parc_txt +"/","/"+ nodes_folder +"/")
    oot = subprocess.run(['mv',nodes,nodes_new])
    if oot.returncode==0:
        df.at[i,"Path_nodes"] = nodes_new

#* WMFODs: instead could do on the cluster via ppmi_tckgen_cluster
rf_algo = 'tournier' #'msmt_5tt','dhollander'
fods_folder = os.path.join(act_folder,'dMRI_fods'); os.system('mkdir -p %s' % fods_folder)
#* Re-run these after fixing the masks
indices_to_rerun = df.index[df['Subject ID'].isin([3114, 3765, 3767, 3768, 3857])]

for i in df.index.tolist(): #indices_to_rerun: #
    sid = df.at[i,'Subject ID']
    dwi = df.at[i,'Path_dMRI_biascorrected']
    dwi_mask = dwi.replace('/dMRI_biascorrect/','/dMRI_mask/').replace('.mif','_mask.mif')
    fivett = df.at[i,sMRI_5tt_txt]
    wm_response_txt  = os.path.join(fods_folder,'%s_wm_response_%s.txt' % (sid,rf_algo))
    gm_response_txt  = os.path.join(fods_folder,'%s_gm_response_%s.txt' % (sid,rf_algo))
    csf_response_txt = os.path.join(fods_folder,'%s_csf_response_%s.txt' % (sid,rf_algo))
    voxels_mif       = os.path.join(fods_folder,'%s_voxels_%s.mif' % (sid,rf_algo))
    #* dwi2response
    # > PPMI has only two b-values, which precludes multi-shell multi-tissue CSD, 
    # > so use 'dwi2response tournier' rather than msmt_5tt or dhollander 
    # > (which will output matrices rather than vectors in the RF txt file)
    #cmd = ['dwi2response','dhollander','-shells','0,1000',dwi,wm_response_txt,gm_response_txt,csf_response_txt,'-voxels',voxels_mif]
    #cmd = ['dwi2response','msmt_5tt',dwi,fivett,wm_response_txt,gm_response_txt,csf_response_txt,'-voxels',voxels_mif]
    cmd = ['dwi2response',rf_algo,dwi,wm_response_txt]
    if not os.path.exists(wm_response_txt):
        oot = subprocess.run(cmd)
        orc = oot.returncode
    else:
        print(' Subject %s: %s exists' % (sid,wm_response_txt))
        orc = 0
    if orc==0:
        print(' Subject %s: dwi2response completed' % sid)
    else:
        print(' Subject %s: dwi2response failed (return code %i)' % (sid,orc))
    #* dwi2fod
    wm_fods_mif = os.path.join(fods_folder,'%s_wm_fods_%s.mif' % (sid,rf_algo))
    gm_fods_mif = os.path.join(fods_folder,'%s_gm_fods_%s.mif' % (sid,rf_algo))
    csf_fods_mif = os.path.join(fods_folder,'%s_csf_fods_%s.mif' % (sid,rf_algo))
    cmd = ['dwi2fod','csd','-mask',dwi_mask,dwi,wm_response_txt,wm_fods_mif] 
    #cmd = ['dwi2fod','csd',dwi,gm_response_txt,gm_fods_mif,csf_response_txt,csf_fods_mif]
    if not os.path.exists(wm_fods_mif):
        oot = subprocess.run(cmd)
        #os.system(' '.join(cmd))
        orc = oot.returncode
    else:
        print(' Subject %s: %s exists' % (sid,wm_fods_mif))
    if orc==0:
        print(' Subject %s: dwi2fod completed' % sid)
        df.at[i,"Path_wm_fod"] = wm_fods_mif
        #df.at[i,"Path_gm_fod"] = gm_fods_mif
        #df.at[i,"Path_csf_fod"] = csf_fods_mif
    else:
        print(' Subject %s: dwi2fod failed (return code %i)' % (sid,orc))

#* Check the response functions:
# shview wm_response.txt

# #* MSMT-only: Check the FODs: convert to RGB image
# for i in df.index.tolist():
#     sid = df.at[i,'Subject ID']
#     wm_fods_mif = os.path.join(fods_folder,'%s_wm_fods_%s.mif' % (sid,rf_algo))
#     tissue_rgb_mif = wm_fods_mif.replace('wm_fods','tissueRGB')
#     cmd = 'mrconvert %s - -coord 3 0 | mrcat CSF.mif GM.mif - %s -axis 3' % (wm_fods_mif,tissue_rgb_mif)
#     if os.path.exists(wm_fods_mif):
#         df.at[i,"Path_wm_fod"] = wm_fods_mif

# mrconvert WM_FODs.mif - -coord 3 0 | mrcat CSF.mif GM.mif - tissueRGB.mif -axis 3
# mrview tissueRGB.mif -odf.load_sh WM_FODs.mif



#*** 7. mtnormalise
print('Running mtnormalise on WM FODs')
for i in df.index.tolist(): #indices_to_rerun:
    sid = df.at[i,'Subject ID']
    dwi = df.at[i,'Path_dMRI_biascorrected']
    dwi_mask = dwi.replace('/dMRI_biascorrect/','/dMRI_mask/').replace('.mif','_mask.mif')
    wm_fods_mif = os.path.join(fods_folder,'%s_wm_fods_%s.mif' % (sid,rf_algo))
    wm_fods_normed = wm_fods_mif.replace('.mif','_normed.mif')
    
    cmd = ['mtnormalise',wm_fods_mif,wm_fods_normed,'-mask',dwi_mask]
    if not os.path.exists(wm_fods_normed):
        oot = subprocess.run(cmd)
        orc = oot.returncode
    else:
        print(' Normalise WN FOD exists for %s' % (sid))
        orc = 0
    if orc==0:
        print(' Subject %s: mtnormalise completed' % sid)
    else:
        print(' Subject %s: mtnormalise failed (return code %i)' % (sid,orc))


#*** 8. Tractography
print("      ...then tractography")
cmd_tckgen_cluster_freesurfer = 'cd /cluster/project9/HCP_subjects/anatomically_constrained_tractography; mkdir ADNI/act/5ttgen_freeserfer;python scripts/adni_tckgen_cluster.py freesurfer/5tt wm_fods freesurfer'

# #*** 9. Connectomes
# print("         ...then form the connectomes")
# nodes_uint32_bool = True
# batch_cmd = [
#     'for_each',
#     'sMRI_nodes/*nodes*.mif','-nthreads','%i' % n_cpus,':',
#     'mrconvert','-datatype','uint32','IN','sMRI_nodes/PRE_uint32.mif'
# ]
# if nodes_uint32_bool:
#     for_each_check = os.system(' '.join(batch_cmd))
# tck2connectome_bool = True
# #* for_each fail...
# # batch_cmd = [
# #     'for_each', '-nthreads','%i' % n_cpus,
# #     'tck_freesurfer/*tcksift4M.tck',':', #'sMRI_freesurfer/*nodes*uint32.mif',':',
# #     #'echo','sMRI_freesurfer/UNI*uint32.mif'
# #     'tck2connectome','-assignment_all_voxels','IN','sMRI_freesurfer/UNI_uint32.mif','tck_freesurfer/PRE_connectome.tsv'
# # ]
# # if tck2connectome_bool:
# #     for_each_check = os.system(' '.join(batch_cmd))
# tail = '_tckgen32M_tckedit16M_tcksift4M.tck'
# fold = os.path.join(act_folder,'tck_freesurfer')
# label_txt = sMRI_5tt_txt.replace('Path_5tt_','')
# for i in df.index.tolist(): #indices_to_rerun:
#     sid = df.at[i,'Subject ID']
#     tcksift = os.path.join(fold,os.path.basename(df.at[i,sMRI_5tt_txt]).split('.')[0] + tail)
#     if os.path.exists(tcksift):
#         nodes_uint32 = df.at[i,sMRI_nodes_txt].replace('.mif','_uint32.mif').replace('sMRI_freesurfer','sMRI_nodes')
#         connectome_tsv = tcksift.replace('.tck',label_txt + '_connectome.tsv')
#         cmd = ['tck2connectome','-assignment_all_voxels',tcksift,nodes_uint32,connectome_tsv]
#         if not os.path.exists(connectome_tsv):
#             oot = subprocess.run(cmd)
#             orc = oot.returncode
#         else:
#             print(' Connectome exists for %s' % (sid))
#             orc = 0
#         if orc==0:
#             print(' Subject %s: tck2connectome completed' % sid)
#             df.at[i,'Path_connectome_' + label_txt] = connectome_tsv
#         else:
#             print(' Subject %s: tck2connectome failed (return code %i)' % (sid,orc))
        


# print('Apparent errors in the following connectomes: 3114, 3767, 3768, 3857 \n All because dwi2mask produced a weird mask focussed on the spinal cord. Fixed the masks using dwi2mak on the raw images, then re-ran dwi2fod etc..')
# print('Still awaiting the tractography for this one: 3765')



